var documenterSearchIndex = {"docs":
[{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"using Markdown, GRASS\nlicense_file = joinpath(pkgdir(GRASS), \"LICENSE.md\")\nif !isfile(license_file)\n    license_file = joinpath(pkgdir(GRASS), \"...\", \"LICENSE.md\")\nend\nMarkdown.parse_file(license_file)","category":"page"},{"location":"input_data/description/#Input-Data-Description","page":"Input Data Description","title":"Input Data Description","text":"","category":"section"},{"location":"longlist/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"longlist/","page":"Index","title":"Index","text":"","category":"page"},{"location":"longlist/","page":"Index","title":"Index","text":"Modules = [GRASS]","category":"page"},{"location":"longlist/#GRASS.DiskParams-Tuple{}","page":"Index","title":"GRASS.DiskParams","text":"DiskParams(; N=132, Nt=50, inclination=90.0)\n\nConstruct a DiskParams composite type instance. In the coordinate system, the x- and z- axes are sky-plane, and the y-axis is along the observer-to-star- center vector.\n\nArguments\n\nN=197: Number of stellar latitude grid elements. Should be set to 197 for physical validity.\nNt=50: Number of 15-second time steps.\nradius=1.0: Radius of model star. Default is one solar radius.\ninclination=90.0: Sky-plane inclination of model stellar disk. 90 degrees is equator on.\nu1=0.4: Quadratic limb darkening law coefficient.\nu2=0.25: Quadratic limb darkening law coefficient\nvsini=2067.03346686649251345: Equatorial rotational velocity magnitude in units of meters per second.\nA=14.713: Differential rotation coefficient. Units of deg/day.\nB=-2.396: Differential rotation coefficient. Units of deg/day.\nC=-1.787: Differential rotation coefficient. Units of deg/day.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.SolarData-Tuple{}","page":"Index","title":"GRASS.SolarData","text":"SolarData(; dir=soldir, relative=true, ...)\n\nConstruct a SpecParams composite type instance.\n\nArguments\n\ndir::String=soldir: Directory containing the pre-processed input data. Default directory is set in src/config.jl\nrelative::Bool=true: Set whether bisectors are measured on absolute wavelength scale or expressed relative to rest wavelength of the line.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.SpecParams","page":"Index","title":"GRASS.SpecParams","text":"SpecParams(lines, depths, geffs, conv_blueshifts, variability, resolution, lambdas, templates)\n\n\n\n\n\n","category":"type"},{"location":"longlist/#GRASS.SpecParams-Tuple{SpecParams, String}","page":"Index","title":"GRASS.SpecParams","text":"SpecParams(spec, template_file)\n\nReturn a copy of spec with only the synthetic line parameters corresponding to template_file\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.SpecParams-Tuple{}","page":"Index","title":"GRASS.SpecParams","text":"SpecParams(; lines=[], depths=[], variability=[], resolution=7e5)\n\nConstruct a SpecParams composite type instance. If variability is not specified, all lines are variable by default.\n\nArguments\n\nlines::AbstractArray{Float64,1}=[]: List of line centers (in angstroms)\ndepths::AbstractArray{Float64,1}=[]: List of line depths\nvariability::AbstractArray{Bool,1}=[]: Array of booleans controlling whether corresponding line has variability.\nresolution::Float64=7e8: Spectral resolution of spectrum\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_bisector_bottom-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, T}} where T<:AbstractFloat","page":"Index","title":"GRASS.calc_bisector_bottom","text":"From Dall et al. 2006\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_bisector_curvature-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Index","title":"GRASS.calc_bisector_curvature","text":"From Dall et al. 2006\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_bisector_inverse_slope-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Index","title":"GRASS.calc_bisector_inverse_slope","text":"From Queloz et al. 2001\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_bisector_slope-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Index","title":"GRASS.calc_bisector_slope","text":"From Dall et al. 2006\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_bisector_span-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Index","title":"GRASS.calc_bisector_span","text":"From various (TODO)\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_ccf-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T1}, AbstractVector{T1}, AbstractVector{T1}, T1}} where {T1<:AbstractFloat, T2<:EchelleCCFs.AbstractCCFMaskShape}","page":"Index","title":"GRASS.calc_ccf","text":"calc_ccf(lambdas, flux, lines, depths, resolution; normalize=true)\n\nCompute the cross correlation function from a spectrum (Î»s and flux) with a mask computed from a line list (lines).\n\nArguments\n\nlambdas::AbstractArray{Float64,1}: List of wavelengths in spectrum.\nflux::AbstractArray{Float64,1}: List of flux in spectrum.\nlines::AbstractArray{Float64,1}: List of line centers for use in CCF mask.\ndepths::AbstractArray{Float64,1}: List of line depths for use as weights in CCF mask.\nresolution::Float64: Spectral resolution of spcectrum.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_rms-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Index","title":"GRASS.calc_rms","text":"calc_rms(A)\n\nCalculate the RMS of given data about the observed mean.\n\nArguments\n\nA::AbstractArray{Float64,1}: 1D array containing data for RMS calculation\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_rvs_from_ccf-Union{Tuple{T}, Tuple{AbstractVector{Float64}, AbstractVector{Float64}}} where T<:EchelleCCFs.RVFromCCF.AbstractMeasureRvFromCCF","page":"Index","title":"GRASS.calc_rvs_from_ccf","text":"calc_rvs_from_ccf(v_grid, ccf)\n\nCalculate apparent radial velocity from a CCF and velocity grid.\n\nArguments\n\nv_grid::AbstractArray{Float64,1}: List of velocities returned by calc_ccf.\nccf::AbstractArray{Float64,1}: CCF values returned by calc_ccf.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.patch_velocity_los-Union{Tuple{T}, Tuple{T, T, DiskParams{T}}} where T<:AbstractFloat","page":"Index","title":"GRASS.patch_velocity_los","text":"patch_velocity_los(x, y; rstar, pole)\n\nCompute line of sight velocity of a patch of stellar surface given by x,y (assumed in [-1,1]). Return value is in (Rsol/day)/speed of light (i.e., dimensionless like z = v/c)\n\nArguments\n\nrstar::Float64=1.0: in R_sol (affects return velocity, but not x,y)\npole = (0,1,0): unit vector for stellar rotation axis (default is equator-on)\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.rotation_period-Tuple{T} where T<:AbstractFloat","page":"Index","title":"GRASS.rotation_period","text":"rotation_period(sin_lat; A=14.713, B=2.396, C=1.787)\n\nCalculate stellar rotation period in days at given sine of latitude.\n\nArguments\n\nsin_lat::Float64: Sine of stellar latitude.\nA::Float64=14.713: Coefficient from Snodgrass & Ulrich (1990)\nB::Float64=2.396: Coefficient from Snodgrass & Ulrich (1990)\nC::Float64=1.787: Coefficient from Snodgrass & Ulrich (1990)\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.synthesize_spectra-Union{Tuple{T}, Tuple{SpecParams{T}, DiskParams{T}}} where T<:AbstractFloat","page":"Index","title":"GRASS.synthesize_spectra","text":"synthesize_spectra(spec, disk; seed_rng=false, verbose=true, top=NaN)\n\nSynthesize spectra given parameters in spec and disk instances.\n\nArguments\n\nspec::SpecParams: SpecParams instance\ndisk::DiskParams: DiskParams instance\n\n\n\n\n\n","category":"method"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"GRASS is written entirely in Julia and requires Julia v1.9 or greater. Installation instructions for Julia are available from julialang.org; alternatively, Julia can be trivially installed on a Mac via homebrew.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The installation of GRASS itself only requires a few steps to install. Simply clone the repo to your desired directory...","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"cd DIRECTORY\ngit clone git@github.com:palumbom/GRASS.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"... and then add it with Julia's Pkg:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(path=\"DIRECTORY\")\nusing GRASS","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you wish to develop or otherwise contribute to GRASS, instead add the package in develop mode:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.develop(path=\"DIRECTORY\")\nusing GRASS","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Upon first invocation of GRASS, Julia will automatically install the package dependencies and download the required input data. The input data can be re-installed by invoking","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Pkg.build(\"GRASS\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Alternatively, these data can be directly downloaded from Zenodo.","category":"page"},{"location":"examples/advanced/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"examples/advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Examples of more advanced usage of GRASS can be found in the figures/ directory. These scripts were used to generate the figures that can be found in the GRASS paper. For clarity, a few specific advanced use cases are highlighted below.","category":"page"},{"location":"examples/advanced/#Accessing-the-Input-Data","page":"Advanced Usage","title":"Accessing the Input Data","text":"","category":"section"},{"location":"examples/advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The \"input data\" described in the GRASS paper can be accessed as follows:","category":"page"},{"location":"examples/advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using GRASS\n\n# get input data\ninput_data = GRASS.SolarData()","category":"page"},{"location":"examples/advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The  input_data variable is an instance of the SolarData composite type. It contains the bisector and width measurements for all epochs of the input data. The data are stored in dictionaries keyed by tuples of symbols representing a location on the disk. Accessing the data at a location on the disk is as simple as specifying the appropriate key.","category":"page"},{"location":"examples/advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"# get bisector data at disk center\nwav = input_data.wav[(:c, :mu10)]\nbis = input_data.bis[(:c, :mu10)]","category":"page"},{"location":"examples/advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"In the above code, wav is a 2D array of wavelengths. Each column contains a measurement of wavelength corresponding to the intensity measured in the corresponding column of bis at a given time. Plotting a bisector in matplotlib simply entails slicing out the desired column.","category":"page"},{"location":"examples/advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"plt.plot(wav[:,1], bis[:,1])\nplt.show()","category":"page"},{"location":"examples/advanced/#Measuring-a-Line-Bisector","page":"Advanced Usage","title":"Measuring a Line Bisector","text":"","category":"section"},{"location":"examples/advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"GRASS can also compute bisectors for absorption lines or CCF profiles. A detailed example of this can be seen in the code for Figure 3. A streamlined version is presented below. First, GRASS is used to generate some synthetic spectra (exactly as in the basic use example):","category":"page"},{"location":"examples/advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using GRASS\n\n# parameters for lines in the spectra\nlines = [5434.5]     # array of line centers in angstroms\ndepths = [0.75]      # continuum-normalized depth of lines\nresolution = 7e5     # spectral resolution of the output spectra\nspec = SpecParams(lines=lines, depths=depths, resolution=resolution)\n\n# specify number of epochs (default 15-second spacing)\ndisk = DiskParams(Nt=25)\n\n# synthesize the spectra\nwavelengths, flux = synthesize_spectra(spec, disk)","category":"page"},{"location":"examples/advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Then, we call the GRASS.measure_bisector function:","category":"page"},{"location":"examples/advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"wav_synth, bis_synth = GRASS.measure_bisector(wavelengths, flux, interpolate=true, top=0.9)","category":"page"},{"location":"examples/advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Two methods for calculating bisectors are implemented. By default, GRASS will attempt to interpolate the absorption line profile onto a uniform grid of flux values. Then the bisector is calculated as the average wavelength value on the left and right wings of the absorption line. Interpolation usually provides cleaner results, but it will fail if the line profile is sufficiently noisy. In this case, if interpolation=false, GRASS will use an iterative approach that is more stable, but less precise.","category":"page"},{"location":"input_data/manipulation/#Input-Data-Manipulation","page":"Input Data Manipulation","title":"Input Data Manipulation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = GRASS","category":"page"},{"location":"#Introduction-to-GRASS","page":"Introduction","title":"Introduction to GRASS","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"GRASS is Julia library designed to produce realistic stellar spectra with time-variable granulation signatures. Based on real observations of the Sun, GRASS is a first-of-its-kind simulation tool which does not rely on magnetohydrodynamic simulations to produce its spectra.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation for GRASS provides instructions for installation and examples for a few basic and advanced use cases. Please reference the GRASS paper for an in-depth review of the motivation and implementation of GRASS.","category":"page"},{"location":"#Citing-GRASS","page":"Introduction","title":"Citing GRASS","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you use GRASS in your research, please cite the latest release as well as the GRASS paper.","category":"page"},{"location":"examples/basic/#Basic-Usage","page":"Basic Usage","title":"Basic Usage","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Usage","title":"Basic Usage","text":"The most basic use case of GRASS is generating time series of synthetic spectra and measuring apparent velocities. These can both be done in only a few lines of code.","category":"page"},{"location":"examples/basic/#Generating-Synthetic-Spectra","page":"Basic Usage","title":"Generating Synthetic Spectra","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Usage","title":"Basic Usage","text":"The simplest use case for GRASS is the generation of time series of synthetic spectra. This can be done in only a few lines of code. The following example generates 25 spectra consisting of a single line at 5434.5 Angstroms. By default, the temporal spacing of the spectra is 15 seconds.","category":"page"},{"location":"examples/basic/","page":"Basic Usage","title":"Basic Usage","text":"using GRASS\n\n# parameters for lines in the spectra\nlines = [5434.5]     # array of line centers in angstroms\ndepths = [0.75]      # continuum-normalized depth of lines\nresolution = 7e5     # spectral resolution of the output spectra\nspec = SpecParams(lines=lines, depths=depths, resolution=resolution)\n\n# specify number of epochs (default 15-second spacing)\ndisk = DiskParams(Nt=25)\n\n# synthesize the spectra\nwavelengths, flux = synthesize_spectra(spec, disk)","category":"page"},{"location":"examples/basic/#Measuring-Velocities","page":"Basic Usage","title":"Measuring Velocities","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Usage","title":"Basic Usage","text":"GRASS wraps the EchelleCCFs package to measure apparent Doppler velocities from spectra.","category":"page"},{"location":"examples/basic/","page":"Basic Usage","title":"Basic Usage","text":"# generate a velocity grid and compute the cross-correlation function\nvel_grid, ccf = calc_ccf(wavelengths, flux, spec, normalize=true)\n\n# measure radial velocities and uncertainties from the ccfs\nrvs, sigs = calc_rvs_from_ccf(vel_grid, ccf)","category":"page"}]
}
