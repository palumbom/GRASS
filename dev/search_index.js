var documenterSearchIndex = {"docs":
[{"location":"license/#License","page":"License","title":"License","text":"using Markdown, GRASS\nlicense_file = joinpath(pkgdir(GRASS), \"LICENSE.md\")\nif !isfile(license_file)\n    license_file = joinpath(pkgdir(GRASS), \"...\", \"LICENSE.md\")\nend\nMarkdown.parse_file(license_file)","category":"section"},{"location":"longlist/#Full-Index","page":"Full Index","title":"Full Index","text":"","category":"section"},{"location":"longlist/#GRASS.DiskParams-Tuple{}","page":"Full Index","title":"GRASS.DiskParams","text":"DiskParams(; N=132, Nt=50, inclination=90.0)\n\nConstruct a DiskParams composite type instance. In the coordinate system, the x- and z- axes are sky-plane, and the y-axis is along the observer-to-star- center vector.\n\nArguments\n\nN=197: number of stellar latitude grid elements; 197 recommended for physical validity.\nNt: number of 15-second time steps (required; must be provided).\nNsubgrid=40: number of subgrid points per surface element for integration.\nradius=1.0: stellar radius in solar units.\ninclination=90.0: sky-plane inclination of the stellar disk (90 degrees is equator-on).\nu1=0.4: quadratic limb-darkening coefficient.\nu2=0.26: quadratic limb-darkening coefficient.\nvsini=2067.033467: equatorial rotational velocity magnitude in meters per second.\nA=14.713: differential rotation coefficient (deg/day).\nB=-2.396: differential rotation coefficient (deg/day).\nC=-1.787: differential rotation coefficient (deg/day).\noffset=false: randomize longitude grid edges by a half-step offset.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.LineProperties","page":"Full Index","title":"GRASS.LineProperties","text":"LineProperties\n\nContainer for metadata about available line templates on disk.\n\n\n\n\n\n","category":"type"},{"location":"longlist/#GRASS.LineProperties-Tuple{}","page":"Full Index","title":"GRASS.LineProperties","text":"LineProperties(; dir=GRASS.soldir, exclude=[\"CI_5380\", \"NaI_5896\"], verbose=false)\n\nLoad line template metadata from HDF5 files in dir.\n\nKeyword Arguments\n\ndir::String=GRASS.soldir: directory containing template .h5 files.\nexclude::AbstractArray{String,1}=[\"CI_5380\", \"NaI_5896\"]: line names to skip.\nverbose::Bool=false: print exclusions while scanning.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.SolarData","page":"Full Index","title":"GRASS.SolarData","text":"SolarData\n\nContainer for line profile data and metadata loaded from a template HDF5 file.\n\n\n\n\n\n","category":"type"},{"location":"longlist/#GRASS.SolarData-Tuple{}","page":"Full Index","title":"GRASS.SolarData","text":"SolarData(; fname=\"\", relative=true, extrapolate=true, adjust_mean=true,\n          contiguous_only=false, fixed_width=false, fixed_bisector=false,\n          strip_cols=true)\n\nLoad solar line profile data from a template HDF5 file.\n\nKeyword Arguments\n\nfname::String=\"\": template filename; defaults to soldir/FeI_5434.h5.\nrelative::Bool=true: store bisectors relative to the rest wavelength.\nextrapolate::Bool=true: extrapolate bisectors when intensities fall below 0.75.\nadjust_mean::Bool=true: match means across noncontiguous datasets.\ncontiguous_only::Bool=false: load only the first contiguous time series per disk position.\nfixed_width::Bool=false: use a fixed width for all epochs at a disk position.\nfixed_bisector::Bool=false: use a fixed bisector for all epochs at a disk position.\nstrip_cols::Bool=true: remove columns flagged as bad before processing.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_bisector-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Real","page":"Full Index","title":"GRASS.calc_bisector","text":"calc_bisector(wavs, flux; kwargs...)\n\nCompute the line bisector from a wavelength grid and flux profile.\n\nArguments\n\nwavs::AbstractArray{<:Real,1}: wavelength grid.\nflux::AbstractArray{<:Real,1}: flux values on the grid.\n\nKeyword Arguments\n\nKeyword arguments are forwarded to calc_line_quantity, including:\n\ncontinuum::Real=1.0: continuum level for normalization.\ntop::Real=0.99: maximum fraction of the continuum to sample.\nnflux::Int=length(flux): number of bisector points to compute.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_bisector_bottom-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, T}} where T<:AbstractFloat","page":"Full Index","title":"GRASS.calc_bisector_bottom","text":"calc_bisector_curvature(bis, int; c1=0.20, c2=0.30, c3=0.40,\n                        c4=0.55, c5=0.75, c6=0.95)\n\nCompute the bisector curvature from three depth regions. Following Dall et al. 2006.\n\nArguments\n\nbis::AbstractArray{<:Real,1}: bisector values as a function of intensity.\nint::AbstractArray{<:Real,1}: normalized intensities corresponding to bis.\n\nKeyword Arguments\n\nc1::Real=0.20: upper depth fraction for the top region.\nc2::Real=0.30: lower depth fraction for the top region.\nc3::Real=0.40: upper depth fraction for the middle region.\nc4::Real=0.55: lower depth fraction for the middle region.\nc5::Real=0.75: upper depth fraction for the bottom region.\nc6::Real=0.95: lower depth fraction for the bottom region.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_bisector_curvature-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Full Index","title":"GRASS.calc_bisector_curvature","text":"From Dall et al. 2006\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_bisector_inverse_slope-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Full Index","title":"GRASS.calc_bisector_inverse_slope","text":"calc_bisector_inverse_slope(bis, int; b1=0.10, b2=0.4, b3=0.55, b4=0.90)\n\nCompute the bisector inverse slope (BIS) from a line bisector and intensity profile. Following Queloz et al. 2001.\n\nArguments\n\nbis::AbstractArray{<:Real,1}: bisector values as a function of intensity.\nint::AbstractArray{<:Real,1}: normalized intensities corresponding to bis.\n\nKeyword Arguments\n\nb1::Real=0.10: upper depth fraction for the top region.\nb2::Real=0.4: lower depth fraction for the top region.\nb3::Real=0.55: upper depth fraction for the bottom region.\nb4::Real=0.90: lower depth fraction for the bottom region.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_bisector_slope-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Full Index","title":"GRASS.calc_bisector_slope","text":"calc_bisector_bottom(bis, int, rv)\n\nCompute the bisector bottom relative to a reference radial velocity. Following Dall et al. 2006.\n\nArguments\n\nbis::AbstractArray{<:Real,1}: bisector values as a function of intensity.\nint::AbstractArray{<:Real,1}: normalized intensities corresponding to bis.\nrv::Real: reference radial velocity to subtract.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_bisector_span-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Full Index","title":"GRASS.calc_bisector_span","text":"calc_bisector_span(bis, int)\n\nCompute the bisector span using the line core and blue wing.\n\nArguments\n\nbis::AbstractArray{<:Real,1}: bisector values as a function of intensity.\nint::AbstractArray{<:Real,1}: normalized intensities corresponding to bis.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_ccf-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T1}, AbstractVector{T1}, AbstractVector{T1}, T1}} where {T1<:AbstractFloat, T2<:EchelleCCFs.AbstractCCFMaskShape}","page":"Full Index","title":"GRASS.calc_ccf","text":"calc_ccf(λs, flux, lines, depths, resolution; normalize=true, mask_width=c_ms/resolution,\n         Δv_max=15e3, Δv_step=100.0, mask_type=TopHatMask)\n\nCompute the cross-correlation function (CCF) from a spectrum (λs, flux) using a line-list mask.\n\nArguments\n\nλs::AbstractArray{Float64,1}: wavelength grid for the spectrum.\nflux::AbstractArray{Float64,1}: flux values on the wavelength grid.\nlines::AbstractArray{Float64,1}: line centers for the CCF mask.\ndepths::AbstractArray{Float64,1}: line depths used as mask weights.\nresolution::Float64: spectral resolution of the spectrum.\n\nKeyword Arguments\n\nnormalize::Bool=true: normalize the CCF to its maximum value.\nmask_width::Float64=c_ms/resolution: mask width in velocity units.\nΔv_max::Float64=15e3: maximum velocity shift (m/s) for the CCF grid.\nΔv_step::Float64=100.0: velocity step size (m/s) for the CCF grid.\nmask_type::Type=TopHatMask: mask shape type from EchelleCCFs.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_rms-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Full Index","title":"GRASS.calc_rms","text":"calc_rms(A)\n\nCalculate the RMS of given data about the observed mean.\n\nArguments\n\nA::AbstractArray{Float64,1}: 1D array containing data for RMS calculation\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.calc_rvs_from_ccf-Union{Tuple{T}, Tuple{AbstractVector{Float64}, AbstractVector{Float64}}} where T<:EchelleCCFs.RVFromCCF.AbstractMeasureRvFromCCF","page":"Full Index","title":"GRASS.calc_rvs_from_ccf","text":"calc_rvs_from_ccf(v_grid, ccf; frac_of_width_to_fit=0.75, fit_type=GaussianFit)\n\nCalculate apparent radial velocity from a CCF and velocity grid.\n\nArguments\n\nv_grid::AbstractArray{Float64,1}: velocity grid returned by calc_ccf.\nccf::AbstractArray{Float64,1}: CCF values returned by calc_ccf.\n\nKeyword Arguments\n\nfrac_of_width_to_fit::Float64=0.75: fraction of the CCF width used in the fit.\nfit_type::Type=GaussianFit: fit model from EchelleCCFs.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.patch_velocity_los-Union{Tuple{T}, Tuple{T, T, DiskParams{T}}} where T<:AbstractFloat","page":"Full Index","title":"GRASS.patch_velocity_los","text":"patch_velocity_los(x, y; rstar, pole)\n\nCompute line of sight velocity of a patch of stellar surface given by x,y (assumed in [-1,1]). Return value is in (Rsol/day)/speed of light (i.e., dimensionless like z = v/c)\n\nArguments\n\nrstar::Float64=1.0: in R_sol (affects return velocity, but not x,y)\npole = (0,1,0): unit vector for stellar rotation axis (default is equator-on)\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.rotation_period-Tuple{T} where T<:AbstractFloat","page":"Full Index","title":"GRASS.rotation_period","text":"rotation_period(sin_lat; A=14.713, B=2.396, C=1.787)\n\nCalculate stellar rotation period in days at given sine of latitude.\n\nArguments\n\nsin_lat::Float64: Sine of stellar latitude.\nA::Float64=14.713: Coefficient from Snodgrass & Ulrich (1990)\nB::Float64=2.396: Coefficient from Snodgrass & Ulrich (1990)\nC::Float64=1.787: Coefficient from Snodgrass & Ulrich (1990)\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.synthesize_spectra-Union{Tuple{T}, Tuple{SpecParams{T}, DiskParams{T}}} where T<:AbstractFloat","page":"Full Index","title":"GRASS.synthesize_spectra","text":"synthesize_spectra(\n    spec,\n    disk;\n    seed_rng=false,\n    verbose=true,\n    use_gpu=false,\n    precision=Float64,\n    skip_times=falses(disk.Nt),\n    contiguous_only=false,\n    show_progress=true,\n)\n\nSynthesize spectra given parameters in spec and disk instances.\n\nArguments\n\nspec::SpecParams: spectral synthesis parameters (line list, templates, wavelength grid).\ndisk::DiskParams: disk simulation parameters (grid size, time samples, geometry).\n\nKeyword Arguments\n\nseed_rng::Bool=false: re-seed RNG with a fixed seed per template.\nverbose::Bool=true: print progress messages for template loading and simulation.\nuse_gpu::Bool=false: run the GPU implementation when available.\nprecision::DataType=Float64: GPU precision (Float32 or Float64); see Caveats\nskip_times::BitVector=falses(disk.Nt): time indices to skip in the simulation loop.\ncontiguous_only::Bool=false: restrict to contiguous line groups when loading templates.\nshow_progress::Bool=true: enable progress reporting inside the simulation.\n\n\n\n\n\n","category":"method"},{"location":"longlist/#GRASS.synthesize_spectra_resolved-Union{Tuple{T}, Tuple{AbstractVector{T}, SpecParams{T}, DiskParams{T}}} where T<:AbstractFloat","page":"Full Index","title":"GRASS.synthesize_spectra_resolved","text":"synthesize_spectra(spec, disk; seed_rng=false, verbose=true, top=NaN)\n\nSynthesize spectra given parameters in spec and disk instances.\n\nArguments\n\nspec::SpecParams: SpecParams instance\ndisk::DiskParams: DiskParams instance\n\n\n\n\n\n","category":"method"},{"location":"examples/advanced/#Manipulating-Input-Data","page":"Manipulating Input Data","title":"Manipulating Input Data","text":"Examples of more advanced usage of GRASS can be found in the figures/ directory. These scripts were used to generate the figures that can be found in the GRASS paper. For clarity, a few specific advanced use cases are highlighted below.","category":"section"},{"location":"examples/advanced/#Accessing-the-Input-Data","page":"Manipulating Input Data","title":"Accessing the Input Data","text":"The \"input data\" described in the GRASS paper can be accessed as follows:\n\nusing GRASS\n\n# get input data\ninput_data = GRASS.SolarData()\n\nThe  input_data variable is an instance of the SolarData composite type. It contains the bisector and width measurements for all epochs of the input data. The data are stored in dictionaries keyed by tuples of symbols representing a location on the disk. Accessing the data at a location on the disk is as simple as specifying the appropriate key.\n\n# get bisector data at disk center\nwav = input_data.wav[(:c, :mu10)]\nbis = input_data.bis[(:c, :mu10)]\n\nIn the above code, wav is a 2D array of wavelengths. Each column contains a measurement of wavelength corresponding to the intensity measured in the corresponding column of bis at a given time. Plotting a bisector in matplotlib simply entails slicing out the desired column.\n\nplt.plot(wav[:,1], bis[:,1])\nplt.show()","category":"section"},{"location":"caveats/#Caveats","page":"Caveats","title":"Caveats","text":"Simulations produced by GRASS are subject to a number of caveats. For a full explanation of these limitations, it is recommended to read the relevant papers presenting GRASS:\n\nPalumbo et al. (2022)\nPalumbo et al. (2024a)","category":"section"},{"location":"caveats/#GPU-Implementation","page":"Caveats","title":"GPU Implementation","text":"GRASS includes a GPU implementation that has been validated to reproduce the results of the fiducial CPU implementation within numerical precision. However, catastrophic cancellation in an internal interpolation operation can create large flux errors when using single precision floats (see the figure below, reproduced from Palumbo et al. 2024a). By default, GRASS uses double precision floats in the GPU implementation, but this may incur a performance penalty for certain hardware. \n\n(Image: gpu_accuracy)","category":"section"},{"location":"#GRASS-GRanulation-And-Spectrum-Simulator","page":"Quickstart","title":"GRASS - GRanulation And Spectrum Simulator","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: arXiv) (Image: arXiv)\n\nGRASS is a Julia package designed to produce time series of stellar spectra with realistic line-shape changes from solar granulation. \n\nGRASS v1.0.x is described in detail in Palumbo et al. (2022); the results of this paper can be reproduced using the showyourwork workflow from this repo. \n\nGRASS v2.0.x is presented in Palumbo et al. (2024a); the figures and quantitative results presented therein are reproducable with this repo. ","category":"section"},{"location":"#Installation","page":"Quickstart","title":"Installation","text":"GRASS is written entirely in Julia and requires Julia v1.9 or greater. Installation instructions for Julia are available from julialang.org.\n\nGRASS itself only requires a few steps to install. Simply clone the repo to your desired directory...\n\ngit clone git@github.com:palumbom/GRASS.git\ncd GRASS \njulia\n\n... and then add it with Julia's built-in package manager, Pkg:\n\nusing Pkg\nPkg.add(path=\".\") # assuming you are in /PATH/TO/GRASS\nusing GRASS\n\nIf you wish to develop or otherwise contribute to GRASS, instead add the package in develop mode:\n\nusing Pkg\nPkg.develop(path=\".\") # assuming you are in /PATH/TO/GRASS\nusing GRASS\n\nUpon first invocation of GRASS, Julia will automatically install the package dependencies and download the required input data. The input data can be re-installed by invoking\n\nPkg.build(\"GRASS\")\n\nAlternatively, these data can be directly downloaded from Zenodo.","category":"section"},{"location":"#Basic-Example","page":"Quickstart","title":"Basic Example","text":"Generating synthetic spectra with GRASS only takes a few lines of Julia:\n\nusing GRASS\nusing PyPlot\n\n# parameters for lines in the spectra\nlines = [5434.5]     # array of line centers in angstroms\ndepths = [0.75]      # continuum-normalized depth of lines\nresolution = 7e5     # spectral resolution of the output spectra\nspec = SpecParams(lines=lines, depths=depths, resolution=resolution)\n\n# specify number of epochs (default 15-second spacing)\ndisk = DiskParams(Nt=25)\n\n# synthesize the spectra\nwavelengths, flux = synthesize_spectra(spec, disk)\n\n# plot the result\nplt.plot(wavelengths, flux)\nplt.xlabel(\"Air Wavelength [Å]\")\nplt.ylabel(\"Normalized Flux\")\nplt.show()\n\n(Image: spectrum)\n\nAdditional details and examples can be found in the documentation.","category":"section"},{"location":"#Citation","page":"Quickstart","title":"Citation","text":"(Image: DOI) (Image: arXiv) (Image: arXiv)\n\nIf you use GRASS in your research, please cite the relevant software release and paper(s). The cffconvert tool can be used to generate a bibtex entry from the included CITATION.cff (or just use the \"cite this repository\" button on the GitHub sidebar).","category":"section"},{"location":"#Author-and-Contact","page":"Quickstart","title":"Author & Contact","text":"(Image: GitHub followers)\n\nThis repo is maintained by Michael Palumbo. You may may contact him via his email - mpalumbo@flatironinstitute.org","category":"section"},{"location":"internals/#Public-Functions","page":"Public Functions","title":"Public Functions","text":"The public functions exported by GRASS are documented on this page. The high-level convenience functions  should meet the needs of most users. Some other potentially useful, lower-level methods are exposed by GRASS and documented below. A full index of all methods defined by GRASS is available in the Full Index.","category":"section"},{"location":"internals/#High-level-Convenience-Functions","page":"Public Functions","title":"High-level Convenience Functions","text":"GRASS provides a few high-level convenience wrappers for generating spectra. ","category":"section"},{"location":"internals/#Velocity-Measurement","page":"Public Functions","title":"Velocity Measurement","text":"GRASS wraps EchelleCCFs.jl to measure velocities from spectra using the CCF method. \n\ncalc_ccf\ncalc_rvs_from_ccf","category":"section"},{"location":"internals/#Input-Data","page":"Public Functions","title":"Input Data","text":"GRASS uses solar observations as input to simulate granulation in spectra. There are a few functions and composite types used to manipulate these data. See also Input Data.\n\nLineProperties\nSolarData","category":"section"},{"location":"internals/#Bisector-Measurement","page":"Public Functions","title":"Bisector Measurement","text":"calc_bisector\ncalc_bisector_inverse_slope\ncalc_bisector_span\ncalc_bisector_bottom\ncalc_bisector_curvature","category":"section"},{"location":"internals/#Utilities","page":"Public Functions","title":"Utilities","text":"calc_rms","category":"section"},{"location":"internals/#GRASS.synthesize_spectra","page":"Public Functions","title":"GRASS.synthesize_spectra","text":"synthesize_spectra(\n    spec,\n    disk;\n    seed_rng=false,\n    verbose=true,\n    use_gpu=false,\n    precision=Float64,\n    skip_times=falses(disk.Nt),\n    contiguous_only=false,\n    show_progress=true,\n)\n\nSynthesize spectra given parameters in spec and disk instances.\n\nArguments\n\nspec::SpecParams: spectral synthesis parameters (line list, templates, wavelength grid).\ndisk::DiskParams: disk simulation parameters (grid size, time samples, geometry).\n\nKeyword Arguments\n\nseed_rng::Bool=false: re-seed RNG with a fixed seed per template.\nverbose::Bool=true: print progress messages for template loading and simulation.\nuse_gpu::Bool=false: run the GPU implementation when available.\nprecision::DataType=Float64: GPU precision (Float32 or Float64); see Caveats\nskip_times::BitVector=falses(disk.Nt): time indices to skip in the simulation loop.\ncontiguous_only::Bool=false: restrict to contiguous line groups when loading templates.\nshow_progress::Bool=true: enable progress reporting inside the simulation.\n\n\n\n\n\n","category":"function"},{"location":"internals/#GRASS.SpecParams","page":"Public Functions","title":"GRASS.SpecParams","text":"SpecParams(lines, depths, geffs, conv_blueshifts, variability, resolution, lambdas, templates)\n\n\n\n\n\n","category":"type"},{"location":"internals/#GRASS.DiskParams","page":"Public Functions","title":"GRASS.DiskParams","text":"DiskParams(; N=132, Nt=50, inclination=90.0)\n\nConstruct a DiskParams composite type instance. In the coordinate system, the x- and z- axes are sky-plane, and the y-axis is along the observer-to-star- center vector.\n\nArguments\n\nN=197: number of stellar latitude grid elements; 197 recommended for physical validity.\nNt: number of 15-second time steps (required; must be provided).\nNsubgrid=40: number of subgrid points per surface element for integration.\nradius=1.0: stellar radius in solar units.\ninclination=90.0: sky-plane inclination of the stellar disk (90 degrees is equator-on).\nu1=0.4: quadratic limb-darkening coefficient.\nu2=0.26: quadratic limb-darkening coefficient.\nvsini=2067.033467: equatorial rotational velocity magnitude in meters per second.\nA=14.713: differential rotation coefficient (deg/day).\nB=-2.396: differential rotation coefficient (deg/day).\nC=-1.787: differential rotation coefficient (deg/day).\noffset=false: randomize longitude grid edges by a half-step offset.\n\n\n\n\n\n","category":"type"},{"location":"examples/basic/#Basic-Usage","page":"Basic Usage","title":"Basic Usage","text":"The most basic use case of GRASS is generating time series of synthetic spectra and measuring apparent velocities. These can both be done in only a few lines of code.","category":"section"},{"location":"examples/basic/#Generating-Synthetic-Spectra","page":"Basic Usage","title":"Generating Synthetic Spectra","text":"The simplest use case for GRASS is the generation of time series of synthetic spectra. This can be done in only a few lines of code. The following example generates 25 spectra consisting of a single line at 5434.5 Angstroms. By default, the temporal spacing of the spectra is 15 seconds.\n\nusing Markdown\ncode = read(joinpath(pwd(), \"..\", \"scripts\", \"simple.jl\"), String)\nbreak_marker = \"# BREAK1\"\nstop_idx = findfirst(break_marker, code)\ncode = stop_idx === nothing ? code : code[1:prevind(code, stop_idx.start)]\nMarkdown.parse(\"```julia\\n\" * code * \"\\n```\")\n\n(Image: formation_temps)","category":"section"},{"location":"examples/basic/#Measuring-Velocities","page":"Basic Usage","title":"Measuring Velocities","text":"GRASS wraps the EchelleCCFs package to measure apparent Doppler velocities from spectra.\n\nusing Markdown\ncode = read(joinpath(pwd(), \"..\", \"scripts\", \"simple.jl\"), String)\nstart_marker = \"# BREAK1\"\nend_marker = \"# BREAK2\"\nstart_idx = findfirst(start_marker, code)\nend_idx = findfirst(end_marker, code)\nif start_idx !== nothing && end_idx !== nothing && start_idx.start < end_idx.start\n    start_nl = findnext('\\n', code, start_idx.start)\n    slice_start = start_nl === nothing ? lastindex(code) + 1 : nextind(code, start_nl)\n    slice_end = prevind(code, end_idx.start)\n    code = slice_start <= slice_end ? code[slice_start:slice_end] : \"\"\nend\nMarkdown.parse(\"```julia\\n\" * code * \"\\n```\")\n\n(Image: formation_temps)","category":"section"},{"location":"examples/basic/#Measuring-Bisectors","page":"Basic Usage","title":"Measuring Bisectors","text":"GRASS wraps the EchelleCCFs package to measure apparent Doppler velocities from spectra.\n\nusing Markdown\ncode = read(joinpath(pwd(), \"..\", \"scripts\", \"simple.jl\"), String)\nstart_marker = \"# BREAK2\"\nend_marker = \"# BREAK3\"\nstart_idx = findfirst(start_marker, code)\nend_idx = findfirst(end_marker, code)\nif start_idx !== nothing && end_idx !== nothing && start_idx.start < end_idx.start\n    start_nl = findnext('\\n', code, start_idx.start)\n    slice_start = start_nl === nothing ? lastindex(code) + 1 : nextind(code, start_nl)\n    slice_end = prevind(code, end_idx.start)\n    code = slice_start <= slice_end ? code[slice_start:slice_end] : \"\"\nend\nMarkdown.parse(\"```julia\\n\" * code * \"\\n```\")\n\n(Image: formation_temps)\n\nWe can also examine the mean-subtracted bisectors to better see the temporal variability in line shape created by granulation.\n\nusing Markdown\ncode = read(joinpath(pwd(), \"..\", \"scripts\", \"simple.jl\"), String)\nstart_marker = \"# BREAK3\"\nend_marker = \"# BREAK4\"\nstart_idx = findfirst(start_marker, code)\nend_idx = findfirst(end_marker, code)\nif start_idx !== nothing && end_idx !== nothing && start_idx.start < end_idx.start\n    start_nl = findnext('\\n', code, start_idx.start)\n    slice_start = start_nl === nothing ? lastindex(code) + 1 : nextind(code, start_nl)\n    slice_end = prevind(code, end_idx.start)\n    code = slice_start <= slice_end ? code[slice_start:slice_end] : \"\"\nend\nMarkdown.parse(\"```julia\\n\" * code * \"\\n```\")\n\n(Image: formation_temps)","category":"section"}]
}
